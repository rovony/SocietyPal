# 09 - SSH Commands Library

**Professional SSH automation scripts for Laravel deployment workflows**

## üìã Library Overview

This library contains production-ready SSH commands and scripts for automating Laravel deployment processes. Commands are organized by deployment phase and tested for reliability.

## üîÑ Deployment Phases

### Phase A: Before Changes (Pre-deployment)
Commands executed immediately once connected to the server, before any files are transferred.

### Phase B: Before Release Link (Zero-downtime preparation)  
Commands executed after files are uploaded but before the new release becomes active.

### Phase C: After Changes (Post-deployment)
Commands executed at the end of deployment after files have been uploaded and the release is active.

## üìö Command Categories

### üîç System Checks
- **A01**: System Preflight Checks
- **A02**: Backup Current Release
- **A03**: Database Backup
- **A04**: Maintenance Mode

### üîó Environment Setup
- **B01**: Initialize Shared Environment
- **B02**: Link Shared Resources
- **B03**: Create Directory Structure
- **B04**: Database Migrations
- **B05**: Application Optimization

### ‚úÖ Post-Deployment
- **C01**: Storage Symlink Creation
- **C02**: Service Restart
- **C03**: Exit Maintenance Mode
- **C04**: Health Checks
- **C05**: Cleanup Operations

## üöÄ Core Command Library

### Phase A: Pre-Deployment Commands

#### A01 - System Preflight Checks

```bash
#!/bin/bash
# A01: System Pre-flight Checks
# Execution: Every deployment
# Purpose: Validate server environment and requirements
# Timeout: 5 minutes

echo "=== System Pre-flight Checks ==="

REQUIRED_COMMANDS=("php" "git" "composer" "curl" "find" "sed" "grep" "date" "touch" "rm" "ln" "mkdir" "chmod" "du" "tail" "xargs" "wc" "awk" "df")
FAILED_CHECKS=0

for cmd in "${REQUIRED_COMMANDS[@]}"; do
  if ! command -v "$cmd" &> /dev/null; then
    echo "‚ö†Ô∏è WARNING: Required command '$cmd' not found."
    FAILED_CHECKS=$((FAILED_CHECKS + 1))
  else
    echo "‚úÖ Command '$cmd' found"
  fi
done

# Check PHP version
if command -v php &> /dev/null; then
  PHP_VERSION=$(php -r "echo PHP_VERSION;")
  if ! php -r "exit(version_compare(PHP_VERSION, '8.0.0', '>=') ? 0 : 1);" &> /dev/null; then
    echo "‚ö†Ô∏è WARNING: PHP version $PHP_VERSION < 8.0.0"
    FAILED_CHECKS=$((FAILED_CHECKS + 1))
  else
    echo "‚úÖ PHP version $PHP_VERSION meets requirements"
  fi
fi

# Check disk space
MIN_DISK_KB=1048576  # 1GB
AVAILABLE_DISK_KB=$(df -k . 2>/dev/null | awk 'NR==2 {print $4}' || echo "999999999")
if [ "$AVAILABLE_DISK_KB" -lt "$MIN_DISK_KB" ]; then
  echo "‚ö†Ô∏è WARNING: Low disk space available"
  FAILED_CHECKS=$((FAILED_CHECKS + 1))
else
  echo "‚úÖ Sufficient disk space available"
fi

if [ "$FAILED_CHECKS" -ne 0 ]; then
  echo "‚ö†Ô∏è Pre-flight completed with $FAILED_CHECKS warning(s)"
else
  echo "‚úÖ All pre-flight checks passed"
fi

exit 0
```

#### A02 - Backup Current Release

```bash
#!/bin/bash
# A02: Backup Current Release
# Execution: Every deployment
# Purpose: Backup current release files and prepare backup directories
# Timeout: 5 minutes

echo "=== Backup Current Release ==="

# Use deployment path variables
DEPLOY_BASE="$HOME/domains/$(basename $PWD)/deploy"
SHARED_PATH="$DEPLOY_BASE/shared"
CURRENT_PATH="$DEPLOY_BASE/current"

# Create backup directory structure
BACKUP_ROOT="$SHARED_PATH/backups"
DEPLOYMENT_TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
CURRENT_BACKUP_DIR="$BACKUP_ROOT/deploy_production_${DEPLOYMENT_TIMESTAMP}"

echo "Creating backup directories..."
mkdir -p "$BACKUP_ROOT" || { echo "‚ùå Failed to create backup root"; exit 1; }
mkdir -p "$CURRENT_BACKUP_DIR" || { echo "‚ùå Failed to create deployment backup dir"; exit 1; }

# Backup current release files (if current release exists)
if [ -L "$CURRENT_PATH" ] && [ -d "$CURRENT_PATH" ]; then
  echo "üîÑ Backing up current release files..."
  
  # Get the actual release directory name
  CURRENT_RELEASE=$(basename "$(readlink "$CURRENT_PATH")")
  BACKUP_NAME="release_${CURRENT_RELEASE}_backup_$(date +%Y%m%d_%H%M%S)"
  
  echo "Creating backup of current release: $CURRENT_RELEASE"
  
  # Create a compressed backup of the current release
  cd "$DEPLOY_BASE/releases" || exit 1
  if tar -czf "$CURRENT_BACKUP_DIR/$BACKUP_NAME.tar.gz" "$CURRENT_RELEASE" 2>/dev/null; then
    BACKUP_SIZE=$(du -sh "$CURRENT_BACKUP_DIR/$BACKUP_NAME.tar.gz" | cut -f1)
    echo "‚úÖ Current release backed up: $BACKUP_NAME.tar.gz ($BACKUP_SIZE)"
  else
    echo "‚ö†Ô∏è Failed to create release backup, continuing..."
  fi
else
  echo "‚ÑπÔ∏è No current release to backup (first deployment)"
fi

# Handle public_html backup (for hosting providers)
cd "$DEPLOY_BASE" || exit 1
if [ -d "public_html" ] && [ ! -L "public_html" ]; then
  echo "üîÑ Backing up existing public_html directory..."
  BACKUP_NAME="public_html.backup.$(date +%Y%m%d_%H%M%S)"
  mv public_html "$CURRENT_BACKUP_DIR/$BACKUP_NAME"
  echo "‚úÖ public_html backed up to: $CURRENT_BACKUP_DIR/$BACKUP_NAME"
else
  echo "‚ÑπÔ∏è No public_html directory to backup (already symlinked)"
fi

# Set permissions
chmod 755 "$BACKUP_ROOT"
chmod 755 "$CURRENT_BACKUP_DIR"

# Store backup path for other commands
echo "$CURRENT_BACKUP_DIR" > "$SHARED_PATH/.current_backup_dir"

echo "‚úÖ Backup system initialized: $CURRENT_BACKUP_DIR"
```

#### A03 - Database Backup

```bash
#!/bin/bash
# A03: Database Backup
# Execution: Every deployment
# Purpose: Create database backup before deployment
# Timeout: 10 minutes

echo "=== Database Backup ==="

# Get backup directory from previous command
SHARED_PATH="$HOME/domains/$(basename $PWD)/deploy/shared"
BACKUP_DIR=$(cat "$SHARED_PATH/.current_backup_dir" 2>/dev/null || echo "$SHARED_PATH/backups/$(date +%Y%m%d_%H%M%S)")

# Check for Laravel application and .env file
if [ -f "$SHARED_PATH/.env" ]; then
  echo "üîÑ Creating database backup..."
  
  # Extract database configuration from .env
  DB_CONNECTION=$(grep "^DB_CONNECTION=" "$SHARED_PATH/.env" | cut -d'=' -f2)
  DB_HOST=$(grep "^DB_HOST=" "$SHARED_PATH/.env" | cut -d'=' -f2)
  DB_PORT=$(grep "^DB_PORT=" "$SHARED_PATH/.env" | cut -d'=' -f2)
  DB_DATABASE=$(grep "^DB_DATABASE=" "$SHARED_PATH/.env" | cut -d'=' -f2)
  DB_USERNAME=$(grep "^DB_USERNAME=" "$SHARED_PATH/.env" | cut -d'=' -f2)
  DB_PASSWORD=$(grep "^DB_PASSWORD=" "$SHARED_PATH/.env" | cut -d'=' -f2)
  
  if [ "$DB_CONNECTION" = "mysql" ] && [ -n "$DB_DATABASE" ]; then
    BACKUP_FILE="$BACKUP_DIR/database_backup_$(date +%Y%m%d_%H%M%S).sql"
    
    # Create MySQL backup
    if mysqldump -h"${DB_HOST:-localhost}" -P"${DB_PORT:-3306}" -u"$DB_USERNAME" -p"$DB_PASSWORD" "$DB_DATABASE" > "$BACKUP_FILE" 2>/dev/null; then
      BACKUP_SIZE=$(du -sh "$BACKUP_FILE" | cut -f1)
      echo "‚úÖ Database backup created: $(basename $BACKUP_FILE) ($BACKUP_SIZE)"
      
      # Compress the backup
      gzip "$BACKUP_FILE"
      echo "‚úÖ Database backup compressed: $(basename $BACKUP_FILE).gz"
    else
      echo "‚ö†Ô∏è Database backup failed, continuing deployment..."
    fi
  else
    echo "‚ÑπÔ∏è Non-MySQL database or no database configured"
  fi
else
  echo "‚ÑπÔ∏è No .env file found, skipping database backup"
fi

echo "‚úÖ Database backup process completed"
```

#### A04 - Enter Maintenance Mode

```bash
#!/bin/bash
# A04: Enter Maintenance Mode
# Execution: Every deployment
# Purpose: Put Laravel application in maintenance mode during deployment
# Timeout: 2 minutes

echo "=== Enter Maintenance Mode ==="

DEPLOY_BASE="$HOME/domains/$(basename $PWD)/deploy"
CURRENT_PATH="$DEPLOY_BASE/current"

if [ -L "$CURRENT_PATH" ] && [ -d "$CURRENT_PATH" ]; then
  echo "üîÑ Enabling Laravel maintenance mode..."
  
  cd "$CURRENT_PATH" || exit 1
  
  # Check if artisan exists
  if [ -f "artisan" ]; then
    # Put application in maintenance mode with custom message
    php artisan down --message="Application is being updated. Please check back in a few minutes." --retry=60
    
    if [ $? -eq 0 ]; then
      echo "‚úÖ Maintenance mode enabled"
      echo "‚ÑπÔ∏è Custom maintenance message set"
    else
      echo "‚ö†Ô∏è Failed to enable maintenance mode, continuing..."
    fi
  else
    echo "‚ÑπÔ∏è No artisan file found, skipping maintenance mode"
  fi
else
  echo "‚ÑπÔ∏è No current release found, skipping maintenance mode"
fi

echo "‚úÖ Maintenance mode process completed"
```

### Phase B: Pre-Release Commands

#### B01 - Initialize Shared Environment

```bash
#!/bin/bash
# B01: Initialize Shared Environment
# Execution: Every deployment
# Purpose: Create and configure shared directories and environment
# Timeout: 3 minutes

echo "=== Initialize Shared Environment ==="

DEPLOY_BASE="$HOME/domains/$(basename $PWD)/deploy"
SHARED_PATH="$DEPLOY_BASE/shared"

# Create shared directory structure
echo "üîÑ Creating shared directory structure..."
mkdir -p "$SHARED_PATH/storage/app/public"
mkdir -p "$SHARED_PATH/storage/framework/cache"
mkdir -p "$SHARED_PATH/storage/framework/sessions"
mkdir -p "$SHARED_PATH/storage/framework/views"
mkdir -p "$SHARED_PATH/storage/logs"

# Set proper permissions
chmod -R 775 "$SHARED_PATH/storage"

# Initialize .env file if it doesn't exist
if [ ! -f "$SHARED_PATH/.env" ]; then
  echo "üîÑ Creating initial .env file..."
  
  if [ -f ".env.example" ]; then
    cp .env.example "$SHARED_PATH/.env"
    echo "‚úÖ .env file created from .env.example"
    echo "‚ö†Ô∏è IMPORTANT: Configure .env file with production settings!"
  else
    echo "‚ö†Ô∏è No .env.example found, creating minimal .env"
    cat > "$SHARED_PATH/.env" << 'EOF'
APP_NAME=Laravel
APP_ENV=production
APP_KEY=
APP_DEBUG=false
APP_URL=https://yourdomain.com

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=your_database
DB_USERNAME=your_username
DB_PASSWORD=your_password
EOF
    echo "‚ö†Ô∏è CRITICAL: Update .env file with actual production settings!"
  fi
else
  echo "‚úÖ Shared .env file already exists"
fi

# Set proper permissions
chmod 644 "$SHARED_PATH/.env"

echo "‚úÖ Shared environment initialized"
```

#### B02 - Link Shared Resources

```bash
#!/bin/bash
# B02: Link Shared Environment
# Execution: Every deployment
# Purpose: Link shared resources to current release
# Timeout: 2 minutes

echo "=== Link Shared Environment ==="

DEPLOY_BASE="$HOME/domains/$(basename $PWD)/deploy"
SHARED_PATH="$DEPLOY_BASE/shared"

# Link .env file
echo "üîó Linking shared .env file..."
if [ -f "$SHARED_PATH/.env" ]; then
  rm -f .env
  ln -s "$SHARED_PATH/.env" .env
  echo "‚úÖ .env file linked"
else
  echo "‚ö†Ô∏è Shared .env file not found!"
fi

# Link storage directory
echo "üîó Linking shared storage directory..."
if [ -d "$SHARED_PATH/storage" ]; then
  rm -rf storage
  ln -s "$SHARED_PATH/storage" storage
  echo "‚úÖ Storage directory linked"
else
  echo "‚ö†Ô∏è Shared storage directory not found!"
fi

# Verify links
echo "üîç Verifying symbolic links..."
if [ -L ".env" ] && [ -e ".env" ]; then
  echo "‚úÖ .env link verified"
else
  echo "‚ùå .env link broken"
fi

if [ -L "storage" ] && [ -d "storage" ]; then
  echo "‚úÖ Storage link verified"
else
  echo "‚ùå Storage link broken"
fi

echo "‚úÖ Shared resources linked"
```

#### B04 - Run Database Migrations

```bash
#!/bin/bash
# B04: Run Database Migrations
# Execution: Every deployment
# Purpose: Execute Laravel database migrations safely
# Timeout: 10 minutes

echo "=== Run Database Migrations ==="

# Check if artisan exists
if [ ! -f "artisan" ]; then
  echo "‚ö†Ô∏è No artisan file found, skipping migrations"
  exit 0
fi

# Check database connectivity
echo "üîç Testing database connectivity..."
if php artisan tinker --execute="DB::connection()->getPdo(); echo 'Database connection successful';" 2>/dev/null; then
  echo "‚úÖ Database connection verified"
else
  echo "‚ùå Database connection failed!"
  echo "‚ö†Ô∏è Skipping migrations due to database connectivity issues"
  exit 0
fi

# Check for pending migrations
echo "üîç Checking for pending migrations..."
PENDING_MIGRATIONS=$(php artisan migrate:status --pending 2>/dev/null | grep -c "N/A" || echo "0")

if [ "$PENDING_MIGRATIONS" -gt 0 ]; then
  echo "üîÑ Found $PENDING_MIGRATIONS pending migration(s)"
  echo "üîÑ Running database migrations..."
  
  # Run migrations with force flag (no interaction)
  if php artisan migrate --force --no-interaction; then
    echo "‚úÖ Database migrations completed successfully"
    
    # Show migration status
    echo "üìä Current migration status:"
    php artisan migrate:status | tail -5
  else
    echo "‚ùå Database migration failed!"
    echo "üîÑ Attempting to rollback..."
    php artisan migrate:rollback --force --no-interaction
    exit 1
  fi
else
  echo "‚ÑπÔ∏è No pending migrations found"
fi

echo "‚úÖ Migration process completed"
```

#### B05 - Optimize Application

```bash
#!/bin/bash
# B05: Optimize Application
# Execution: Every deployment
# Purpose: Cache configurations and optimize Laravel application
# Timeout: 5 minutes

echo "=== Optimize Application ==="

# Check if artisan exists
if [ ! -f "artisan" ]; then
  echo "‚ö†Ô∏è No artisan file found, skipping optimization"
  exit 0
fi

echo "üîÑ Optimizing Laravel application..."

# Clear existing caches
echo "üßπ Clearing existing caches..."
php artisan cache:clear 2>/dev/null || echo "‚ÑπÔ∏è Cache clear skipped"
php artisan config:clear 2>/dev/null || echo "‚ÑπÔ∏è Config clear skipped"
php artisan route:clear 2>/dev/null || echo "‚ÑπÔ∏è Route clear skipped"
php artisan view:clear 2>/dev/null || echo "‚ÑπÔ∏è View clear skipped"

# Cache configurations
echo "‚ö° Caching configurations..."
php artisan config:cache
if [ $? -eq 0 ]; then
  echo "‚úÖ Configuration cached"
else
  echo "‚ö†Ô∏è Configuration caching failed"
fi

# Cache routes
echo "‚ö° Caching routes..."
php artisan route:cache
if [ $? -eq 0 ]; then
  echo "‚úÖ Routes cached"
else
  echo "‚ö†Ô∏è Route caching failed"
fi

# Cache views
echo "‚ö° Caching views..."
php artisan view:cache
if [ $? -eq 0 ]; then
  echo "‚úÖ Views cached"
else
  echo "‚ö†Ô∏è View caching failed"
fi

# Run general optimization
echo "‚ö° Running general optimization..."
php artisan optimize
if [ $? -eq 0 ]; then
  echo "‚úÖ General optimization completed"
else
  echo "‚ö†Ô∏è General optimization failed"
fi

# Verify optimization
echo "üîç Verifying optimization..."
if [ -f "bootstrap/cache/config.php" ]; then
  echo "‚úÖ Config cache file exists"
fi

if [ -f "bootstrap/cache/routes-v7.php" ]; then
  echo "‚úÖ Route cache file exists"
fi

if [ -f "bootstrap/cache/compiled.php" ]; then
  echo "‚úÖ Compiled views cache exists"
fi

echo "‚úÖ Application optimization completed"
```

### Phase C: Post-Deployment Commands

#### C01 - Create Storage Symlink

```bash
#!/bin/bash
# C01: Create Storage Symlink
# Execution: Every deployment
# Purpose: Create public storage symlink for file access
# Timeout: 2 minutes

echo "=== Create Storage Symlink ==="

# Check if artisan exists
if [ ! -f "artisan" ]; then
  echo "‚ö†Ô∏è No artisan file found, skipping storage link"
  exit 0
fi

echo "üîó Creating storage symlink..."

# Remove existing symlink if it exists
if [ -L "public/storage" ]; then
  echo "üîÑ Removing existing storage symlink..."
  rm public/storage
fi

# Create storage symlink
php artisan storage:link

if [ $? -eq 0 ]; then
  echo "‚úÖ Storage symlink created successfully"
  
  # Verify the symlink
  if [ -L "public/storage" ] && [ -d "public/storage" ]; then
    echo "‚úÖ Storage symlink verified"
    echo "üìÅ Symlink target: $(readlink public/storage)"
  else
    echo "‚ö†Ô∏è Storage symlink verification failed"
  fi
else
  echo "‚ö†Ô∏è Storage symlink creation failed"
fi

echo "‚úÖ Storage symlink process completed"
```

#### C03 - Exit Maintenance Mode

```bash
#!/bin/bash
# C03: Exit Maintenance Mode
# Execution: Every deployment
# Purpose: Bring Laravel application out of maintenance mode
# Timeout: 2 minutes

echo "=== Exit Maintenance Mode ==="

DEPLOY_BASE="$HOME/domains/$(basename $PWD)/deploy"
CURRENT_PATH="$DEPLOY_BASE/current"

if [ -L "$CURRENT_PATH" ] && [ -d "$CURRENT_PATH" ]; then
  echo "üîÑ Disabling Laravel maintenance mode..."
  
  cd "$CURRENT_PATH" || exit 1
  
  # Check if artisan exists
  if [ -f "artisan" ]; then
    # Bring application out of maintenance mode
    php artisan up
    
    if [ $? -eq 0 ]; then
      echo "‚úÖ Maintenance mode disabled"
      echo "‚úÖ Application is now live"
    else
      echo "‚ö†Ô∏è Failed to disable maintenance mode"
    fi
  else
    echo "‚ÑπÔ∏è No artisan file found, skipping maintenance mode exit"
  fi
else
  echo "‚ÑπÔ∏è No current release found"
fi

echo "‚úÖ Maintenance mode exit completed"
```

#### C04 - Health Checks

```bash
#!/bin/bash
# C04: Health Checks
# Execution: Every deployment
# Purpose: Verify application health after deployment
# Timeout: 5 minutes

echo "=== Health Checks ==="

DEPLOY_BASE="$HOME/domains/$(basename $PWD)/deploy"
CURRENT_PATH="$DEPLOY_BASE/current"

if [ -L "$CURRENT_PATH" ] && [ -d "$CURRENT_PATH" ]; then
  cd "$CURRENT_PATH" || exit 1
  
  echo "üîç Running application health checks..."
  
  # Check if artisan exists and Laravel is working
  if [ -f "artisan" ]; then
    echo "üîç Testing Laravel application..."
    
    # Test artisan command
    if php artisan --version > /dev/null 2>&1; then
      echo "‚úÖ Laravel artisan working"
      LARAVEL_VERSION=$(php artisan --version)
      echo "‚ÑπÔ∏è $LARAVEL_VERSION"
    else
      echo "‚ùå Laravel artisan not working"
    fi
    
    # Test database connectivity
    echo "üîç Testing database connectivity..."
    if php artisan tinker --execute="DB::connection()->getPdo(); echo 'Database OK';" 2>/dev/null | grep -q "Database OK"; then
      echo "‚úÖ Database connection working"
    else
      echo "‚ö†Ô∏è Database connection issues detected"
    fi
    
    # Check application configuration
    echo "üîç Checking application configuration..."
    if php artisan about 2>/dev/null | grep -q "Environment"; then
      echo "‚úÖ Application configuration loaded"
      echo "üìä Application info:"
      php artisan about | head -5
    else
      echo "‚ö†Ô∏è Application configuration issues"
    fi
  else
    echo "‚ÑπÔ∏è No artisan file found"
  fi
  
  # Check file permissions
  echo "üîç Checking file permissions..."
  if [ -w "storage/logs" ]; then
    echo "‚úÖ Storage directory writable"
  else
    echo "‚ö†Ô∏è Storage directory not writable"
  fi
  
  if [ -w "bootstrap/cache" ]; then
    echo "‚úÖ Bootstrap cache directory writable"
  else
    echo "‚ö†Ô∏è Bootstrap cache directory not writable"
  fi
  
  # Check web server accessibility (if possible)
  if command -v curl > /dev/null 2>&1; then
    echo "üîç Testing web server response..."
    # Try to get the domain from .env or use localhost
    DOMAIN=$(grep "^APP_URL=" .env 2>/dev/null | cut -d'=' -f2 | sed 's|https://||' | sed 's|http://||' || echo "localhost")
    
    HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$DOMAIN" 2>/dev/null || echo "000")
    if [ "$HTTP_STATUS" = "200" ]; then
      echo "‚úÖ Web server responding (HTTP 200)"
    elif [ "$HTTP_STATUS" != "000" ]; then
      echo "‚ö†Ô∏è Web server responding with HTTP $HTTP_STATUS"
    else
      echo "‚ÑπÔ∏è Could not test web server response"
    fi
  fi
else
  echo "‚ÑπÔ∏è No current release found for health checks"
fi

echo "‚úÖ Health checks completed"
```

#### C07 - Cleanup Old Releases

```bash
#!/bin/bash
# C07: Cleanup Old Releases
# Execution: Every deployment
# Purpose: Remove old deployment releases to save disk space
# Timeout: 3 minutes

echo "=== Cleanup Old Releases ==="

DEPLOY_BASE="$HOME/domains/$(basename $PWD)/deploy"
RELEASES_PATH="$DEPLOY_BASE/releases"
KEEP_RELEASES=3  # Number of releases to keep

if [ -d "$RELEASES_PATH" ]; then
  cd "$RELEASES_PATH" || exit 1
  
  echo "üîç Checking for old releases to cleanup..."
  
  # Count total releases
  TOTAL_RELEASES=$(ls -1 | wc -l)
  echo "üìä Total releases found: $TOTAL_RELEASES"
  
  if [ "$TOTAL_RELEASES" -gt "$KEEP_RELEASES" ]; then
    RELEASES_TO_DELETE=$((TOTAL_RELEASES - KEEP_RELEASES))
    echo "üßπ Removing $RELEASES_TO_DELETE old release(s)..."
    
    # Get list of releases to delete (oldest first)
    OLD_RELEASES=$(ls -t | tail -n +$((KEEP_RELEASES + 1)))
    
    for release in $OLD_RELEASES; do
      if [ -d "$release" ]; then
        RELEASE_SIZE=$(du -sh "$release" | cut -f1)
        echo "üóëÔ∏è Removing old release: $release ($RELEASE_SIZE)"
        rm -rf "$release"
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ Removed $release"
        else
          echo "‚ö†Ô∏è Failed to remove $release"
        fi
      fi
    done
    
    echo "‚úÖ Cleanup completed"
  else
    echo "‚ÑπÔ∏è No cleanup needed (keeping $KEEP_RELEASES releases)"
  fi
  
  # Show remaining releases
  echo "üìä Remaining releases:"
  ls -t | head -$KEEP_RELEASES | while read release; do
    RELEASE_SIZE=$(du -sh "$release" | cut -f1)
    echo "   üì¶ $release ($RELEASE_SIZE)"
  done
  
  # Show total disk usage
  TOTAL_SIZE=$(du -sh . | cut -f1)
  echo "üìä Total releases disk usage: $TOTAL_SIZE"
else
  echo "‚ÑπÔ∏è No releases directory found"
fi

echo "‚úÖ Release cleanup completed"
```

## üõ†Ô∏è Platform-Specific Command Sets

### DeployHQ Professional Commands

For DeployHQ deployments, use these optimized command sequences:

```bash
# DeployHQ Pre-deployment
A01-System-Preflight-Checks
A02-Backup-Current-Release
A03-Database-Backup
A04-Enter-Maintenance-Mode

# DeployHQ Pre-release
B01-Initialize-Shared-Environment
B02-Link-Shared-Resources
B04-Run-Database-Migrations
B05-Optimize-Application

# DeployHQ Post-deployment
C01-Create-Storage-Symlink
C03-Exit-Maintenance-Mode
C04-Health-Checks
C07-Cleanup-Old-Releases
```

### GitHub Actions Commands

For CI/CD workflows, use these automation-friendly commands:

```bash
# Minimal command set for automated deployments
A01-System-Preflight-Checks
B02-Link-Shared-Resources
B04-Run-Database-Migrations
B05-Optimize-Application
C01-Create-Storage-Symlink
C04-Health-Checks
```

## üìã Usage Examples

### Complete Deployment Script

```bash
#!/bin/bash
# Complete Laravel deployment script using SSH commands library

set -e  # Exit on any error

echo "üöÄ Starting Laravel deployment..."

# Phase A: Pre-deployment
echo "üìã Phase A: Pre-deployment checks..."
bash A01-System-Preflight-Checks.sh
bash A02-Backup-Current-Release.sh
bash A03-Database-Backup.sh
bash A04-Enter-Maintenance-Mode.sh

# Phase B: Pre-release setup
echo "üìã Phase B: Pre-release setup..."
bash B01-Initialize-Shared-Environment.sh
bash B02-Link-Shared-Resources.sh
bash B04-Run-Database-Migrations.sh
bash B05-Optimize-Application.sh

# Phase C: Post-deployment
echo "üìã Phase C: Post-deployment..."
bash C01-Create-Storage-Symlink.sh
bash C03-Exit-Maintenance-Mode.sh
bash C04-Health-Checks.sh
bash C07-Cleanup-Old-Releases.sh

echo "üéâ Laravel deployment completed successfully!"
```

### Quick Deployment (Essential Commands Only)

```bash
#!/bin/bash
# Quick deployment with essential commands only

echo "‚ö° Quick Laravel deployment..."

# Essential pre-checks
bash A01-System-Preflight-Checks.sh

# Core deployment tasks
bash B02-Link-Shared-Resources.sh
bash B04-Run-Database-Migrations.sh
bash B05-Optimize-Application.sh

# Essential post-deployment
bash C01-Create-Storage-Symlink.sh
bash C04-Health-Checks.sh

echo "‚úÖ Quick deployment completed!"
```

## üîß Customization Guide

### Environment Variables

Set these variables to customize command behavior:

```bash
# Deployment configuration
export KEEP_RELEASES=5          # Number of releases to keep
export BACKUP_RETENTION_DAYS=30 # Days to keep backups
export DEPLOYMENT_TIMEOUT=600   # Deployment timeout in seconds

# Database configuration
export DB_BACKUP_COMPRESSION=true  # Compress database backups
export DB_MIGRATION_TIMEOUT=300    # Migration timeout in seconds

# Application configuration
export OPTIMIZE_LEVEL=full      # full|basic|minimal
export HEALTH_CHECK_RETRIES=3   # Number of health check retries
```

### Custom Command Template

```bash
#!/bin/bash
# [Command ID]: [Command Name]
# Execution: [When to run]
# Purpose: [What this command does]
# Timeout: [Maximum execution time]

echo "=== [Command Name] ==="

# Error handling
set -e
trap 'echo "‚ùå [Command Name] failed at line $LINENO"' ERR

# Pre-checks
echo "üîç Pre-checks..."
# Add pre-check logic here

# Main execution
echo "üîÑ [Main action description]..."
# Add main command logic here

# Post-verification
echo "‚úÖ [Action completed]..."
# Add verification logic here

echo "‚úÖ [Command Name] completed"
```

## üÜò Troubleshooting

### Common Issues

#### Permission Errors
```bash
# Fix common permission issues
chmod -R 775 storage bootstrap/cache
chown -R $USER:www-data storage bootstrap/cache
```

#### Database Connection Issues
```bash
# Test database connectivity
php artisan tinker --execute="
try {
    DB::connection()->getPdo();
    echo 'Database connection: OK';
} catch (Exception \$e) {
    echo 'Database error: ' . \$e->getMessage();
}
"
```

#### Symlink Problems
```bash
# Fix broken symlinks
rm -f .env public/storage
ln -s ../shared/.env .env
php artisan storage:link
```

---

**üéØ Ready to automate your Laravel deployments?**

Choose the appropriate command set for your deployment platform and customize as needed!

üëâ **Popular Command Sets:**
- [DeployHQ Professional Commands](./deployhq-commands.md) for enterprise deployments
- [GitHub Actions Commands](./github-actions-commands.md) for CI/CD automation
- [Manual Deployment Commands](./manual-deployment-commands.md) for traditional hosting
